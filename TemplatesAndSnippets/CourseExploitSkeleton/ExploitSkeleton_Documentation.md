# ExploitSkeleton Documentation

## Overview

This structure is designed for creating OSWE-style exploits in a standardized, reusable, and modular way. It separates concerns (context, logic, helpers) and makes the code easier to extend, debug, and showcase.

---

## Directory Layout

```
my_exploit_project/
├── exploit_skeleton.py         # Reusable base class for all exploits
├── exploit_erka.py             # Script for a specific target using the skeleton
├── context.py                  # ExploitContext class (metadata, persistence)
├── helpers.py                  # Utility functions (e.g., listeners, oracles)
├── requirements.txt
└── README.md
```

---

## 1. ExploitContext

`ExploitContext` stores configuration, authentication, and runtime metadata.

### Features

- Tracks `target_ip`, `attacker_ip`, ports, protocol
- Includes authentication/session metadata (cookies, tokens)
- Handles saving/loading exploit state via JSON

### Example

```python
ctx = ExploitContext(
    target_ip="192.168.1.100",
    target_port=80,
    attacker_ip="10.0.0.1",
    attacker_port=9001,
    protocol="http",
    session_cookie="PHPSESSID=abc123"
)

ctx.save()  # Save to exploit_context.json
```

---

## 2. ExploitSkeleton

`ExploitSkeleton` is a reusable base class that other exploits can extend.

### Responsibilities

- Setup and initialize context
- Register/load users
- Define a `run()` method for core logic
- Abstract common setup tasks

### Usage

```python
from exploit_skeleton import ExploitSkeleton

class MyExploit(ExploitSkeleton):
    def run(self):
        self.logger.info("Running exploit...")
        # exploit logic here

if __name__ == "__main__":
    MyExploit().main()
```

---

## 3. CLI Arguments

Handled in the base class or via extension. Supports:

- `--target-ip`, `--target-port`
- `--attacker-ip`, `--attacker-port`
- `--register`
- `--charset`
- `--user-file`
- `--delay`

### Example

```bash
python3 exploit_erka.py --target-ip 192.168.1.100 --register True --charset ascii
```

---

## 4. helpers.py

Place utility functions here:

- `spawn_listener()`
- `timing_oracle()`
- `str2bool()`
- `parse_flag_from_html()`

---

## 5. Example Flag Extraction

```python
def parse_flag_from_html(html: str) -> Optional[str]:
    soup = BeautifulSoup(html, "html.parser")
    flag_elem = soup.find("span", class_="text-green-600")
    if flag_elem:
        return flag_elem.text.strip().replace("Flag: ", "")
    return None
```

---

## Best Practices

- Explicitly pass attacker IPs (no auto detection)
- Store cookies/session headers in context
- Include full CLI parsing in base class
- Use dataclass for context management
- Log all steps and dump results to artifacts

---

## Future Extensions

- Add report generation from context + log
- Plug into `file_transfer_server`
- Async support (optional) for parallel oracles
