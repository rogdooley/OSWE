import argparse
import httpx
import asyncio
import sys
import json
import shutil
import subprocess
import time

from bs4 import BeautifulSoup
from pathlib import Path
from dataclasses import dataclass, asdict, field
from typing import Optional, Literal, Callable
from concurrent.futures import ThreadPoolExecutor

root_dir = Path(__file__).resolve().parent.parent
sys.path.append(str(root_dir))

# If commomn isn't in ../../common, change root dir or change the imports as appropriate
from common.offsec_logger import OffsecLogger
from common.file_transfer_server import FileTransferServer
from common.IdentityGenerator.identity_generator import IdentityGenerator
from common.IdentityGenerator.specs.identity_spec import IdentitySpec


ARTIFACT_DIR = Path("artifacts")

CHARSETS = {
    "alpha": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "alnum": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
    "hex": "0123456789abcdef",
    "ascii": "".join(chr(i) for i in range(32, 127)),  # printable ASCII
    "symbols": "!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?`~",
    "base64": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=",
    "numeric": "0123456789",
}


@dataclass(slots=True)
class ExploitContext:
    target_ip: str
    target_port: str
    attacker_ip: str
    attacker_port: str
    protocol: str = "http"

    # Auth state
    token: Optional[str] = None
    token_name: Optional[str] = None
    session_cookie: Optional[str] = None

    # Metadata
    vuln_name: Optional[str] = None
    poc_id: Optional[str] = None
    notes: str = ""

    # Runtime fields (ignored in serialization)
    output_path: Path = field(
        default_factory=lambda: Path("exploit_context.json"), repr=False
    )

    def __post_init__(self):
        if isinstance(self.output_path, str):
            self.output_path = Path(self.output_path)

    def target_url(self) -> str:
        return f"{self.protocol}://{self.target_ip}:{self.target_port}"

    def attacker_url(self) -> str:
        return f"{self.protocol}://{self.attacker_ip}:{self.attacker_port}"

    def save(self) -> None:
        """Persist context to a JSON file (excluding runtime fields)."""
        serializable_dict = {
            k: str(v) if isinstance(v, Path) else v
            for k, v in asdict(self).items()
            if k != "output_path"
        }
        with self.output_path.open("w") as f:
            json.dump(serializable_dict, f, indent=2)

    def load(self) -> None:
        """Restore fields from saved file if exists."""
        if self.output_path.exists():
            with self.output_path.open() as f:
                data = json.load(f)
            for key, value in data.items():
                if key == "output_path":
                    setattr(self, key, Path(value))
                else:
                    setattr(self, key, value)


def str2bool(v: str) -> bool:
    return v.lower() in ("yes", "true", "1")


def spawn_external_listener(listening_port: int):
    cmd = f"bash -c 'nc -lvnp {listening_port}; echo Press enter to close; read'"
    if shutil.which("gnome-terminal"):
        subprocess.Popen(["gnome-terminal", "--", "bash", "-c", cmd])
    elif shutil.which("x-terminal-emulator"):
        subprocess.Popen(["x-terminal-emulator", "-e", cmd])
    else:
        print(f"[!] No terminal available. Run manually:\n{cmd}")


def parse_args():
    parser = argparse.ArgumentParser(description="OSWE Chat Application Exploit.")

    parser.add_argument("--target-ip", type=str, required=True, help="Input file path")
    parser.add_argument("--target-port", type=int, default=80, help="Input file path")
    parser.add_argument(
        "--listening-port",
        type=int,
        default=9001,
        help="Port to listen for reverse shell (default: 9001)",
    )
    parser.add_argument(
        "--listening-ip",
        type=str,
        default="127.0.0.1",
        help="IP to listen on for reverse shell (default: 127.0.0.1)",
    )
    parser.add_argument(
        "--delay",
        type=int,
        default=3,
        help="Response delay in seconds for timing inference",
    )
    parser.add_argument(
        "--user-file", type=str, default="user.json", help="Existing exploit user"
    )
    parser.add_argument(
        "--register",
        type=str2bool,
        default=False,
        help="Has the user already been registered.",
    )
    # parser.add_argument(
    #     "--charset",
    #     choices=CHARSETS.keys(),
    #     default="alnum",
    #     help="Charset to use for blind SQLi password extraction.",
    # )
    # parser.add_argument(
    #     "--complexity", choices=["low", "medium", "high"], help="Password complexity"
    # )
    # parser.add_argument(
    #     "--include-address", action="store_true", help="Include street address"
    # )
    # parser.add_argument(
    #     "--include-phone", action="store_true", help="Include phone number"
    # )
    parser.add_argument("--save-file", help="Path to save generated identity JSON")
    # parser.add_argument(
    #     "--proxy", default=None, help="Turn on Burp Suite proxy for debugging."
    # )
    return parser.parse_args()


def main():
    args = parse_args()
    Path(ARTIFACT_DIR).mkdir(parents=True, exist_ok=True)

    # proxies = {"http": "http://127.0.0.1:8080", "https": "http://127.0.0.1:8080"}

    # if args.proxy:
    #     proxies = {"http": args.proxy, "https": args.proxy}
    # else:
    #     proxies = None

    charset = CHARSETS[args.charset]

    log_name = Path.cwd().name
    logger = OffsecLogger(logfile=f"{log_name}.log", debug=True)

    ctx = ExploitContext(
        target_ip=args.target_ip,
        target_port=args.target_port,
        attacker_ip=args.listening_ip,
        attacker_port=args.listening_port,
        protocol="http",
        vuln_name=log_name,
        poc_id="01",
    )

    extras = []
    # if args.include_address:
    #     extras.append("address")
    # if args.include_phone:
    #     extras.append("phone")

    overrides = {}
    if args.complexity:
        overrides["password"] = {"complexity": args.complexity}

    spec = IdentitySpec(
        extras=extras,
        overrides=overrides,
    )

    generator = IdentityGenerator()
    identity = generator.generate_identity(spec)

    if args.save_file:
        generator.save_identity(ARTIFACT_DIR / args.save_file)
        logger.info(f"Identity saved to {ARTIFACT_DIR / args.save_file}")
    else:
        print(generator.as_json())

    # Add code

    ctx.save()


if __name__ == "__main__":
    main()
