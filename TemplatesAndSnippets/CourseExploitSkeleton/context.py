import json
from pathlib import Path
from dataclasses import dataclass, field, asdict
from typing import Optional


@dataclass
class ExploitContext:
    target_ip: str
    target_port: str
    attacker_ip: str
    attacker_port: str
    protocol: str = "http"

    # Auth state
    token: Optional[str] = None
    token_name: Optional[str] = None
    session_cookie: Optional[str] = None

    # Metadata
    vuln_name: Optional[str] = None
    poc_id: Optional[str] = None
    notes: str = ""

    # Runtime fields (ignored in serialization)
    output_path: Path = field(
        default_factory=lambda: Path("exploit_context.json"), repr=False
    )

    def __post_init__(self):
        if isinstance(self.output_path, str):
            self.output_path = Path(self.output_path)

    def target_url(self) -> str:
        return f"{self.protocol}://{self.target_ip}:{self.target_port}"

    def attacker_url(self) -> str:
        return f"{self.protocol}://{self.attacker_ip}:{self.attacker_port}"

    def save(self) -> None:
        """Persist context to a JSON file (excluding runtime fields)."""
        serializable_dict = {
            k: str(v) if isinstance(v, Path) else v
            for k, v in asdict(self).items()
            if k != "output_path"
        }
        with self.output_path.open("w") as f:
            json.dump(serializable_dict, f, indent=2)

    def load(self) -> None:
        """Restore fields from saved file if exists."""
        if self.output_path.exists():
            with self.output_path.open() as f:
                data = json.load(f)
            for key, value in data.items():
                if key == "output_path":
                    setattr(self, key, Path(value))
                else:
                    setattr(self, key, value)
