import argparse
from core.context import ExploitContext
from core.exploit_skeleton import ExploitSkeleton
from common.offsec_logger import OffsecLogger
from common.data_faker import DataFaker

logger = OffsecLogger(logfile="exploit.log", debug=True)


class MyExploit(ExploitSkeleton):
    def setup(self):
        if self.args.register or not Path(self.args.user_file).exists():
            identity = self.faker.generate_identity(
                domain="evil.io",
                username_format="{f}_{last}{##}",
                email_format="{first}.{last}{##}",
                password_length=self.args.password_length,
                num_upper=2,
                num_digits=2,
                num_special=1,
                include_uuid=False,
                include_token=False,
            )
            self.faker.save_identity(self.args.user_file)
            logger.success(f"User generated: {identity}")
        else:
            identity = self.faker.load_identity(self.args.user_file)
            self.faker.last_identity = identity
            logger.info(f"Loaded user: {identity}")

        self.ctx.session_cookie = None
        self.ctx.notes = "Setup complete"
        self.ctx.save()

    def exploit(self):
        logger.info("Starting exploit phase...")
        # Implement specific exploit logic here
        logger.success("Exploit phase completed.")


def str2bool(v: str) -> bool:
    return v.lower() in ("yes", "true", "1")


def parse_args():
    parser = argparse.ArgumentParser(description="Reusable OSWE Exploit Skeleton")
    parser.add_argument("--target-ip", type=str, required=True, help="Input file path")
    parser.add_argument("--target-port", type=int, default=80, help="Input file path")
    parser.add_argument(
        "--password",
        nargs="?",
        const=None,
        help="Password for username. If left blank, a random password will be generated.",
    )
    parser.add_argument(
        "--password-length",
        type=int,
        default=16,
        help="Length of the password if generated.",
    )
    parser.add_argument(
        "--listening-port",
        type=int,
        default=9001,
        help="Port to listen for reverse shell (default: 9001)",
    )
    parser.add_argument(
        "--listening-ip", type=str, help="IP to listen on for reverse shell"
    )
    parser.add_argument(
        "--delay",
        type=int,
        default=3,
        help="Response delay in seconds for timing inference",
    )
    parser.add_argument(
        "--user-file", type=str, default="user.json", help="Existing exploit user"
    )
    parser.add_argument(
        "--register",
        type=str2bool,
        default=False,
        help="Has the user already been registered.",
    )
    parser.add_argument(
        "--charset", choices=["alpha", "alnum", "ascii"], default="alnum"
    )
    parser.add_argument("--use-async", action="store_true")
    return parser.parse_args()


def main():
    args = parse_args()
    ctx = ExploitContext(
        target_ip=args.target_ip,
        target_port=args.target_port,
        attacker_ip=args.listening_ip,
        attacker_port=args.listening_port,
        protocol="http",
    )

    exploit = MyExploit(ctx=ctx, args=args)
    exploit.run()


if __name__ == "__main__":
    main()
